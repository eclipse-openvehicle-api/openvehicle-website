
.. _vapi-auto_code_generation:

Auto Code Generation
====================

This section describes the tools and process used to automatically generate code artifacts for Software Defined Vehicle (SDV) systems. These artifacts include CAN datalink components, vehicle devices, and basic services, based on standardized signal definitions and vehicle-specific configurations.

Quick Summary
-------------

- **sdv_vss_util**: Generates IDL interfaces and component code from VSS CSV.
- **sdv_idl_compiler**: Compiles IDL files into proxy/stub code.
- **sdv_dbc_util**: Generates CAN datalink and FMU code from DBC files.


Tools Overview
--------------

.. _sdv_vss_util:

sdv_vss_util
~~~~~~~~~~~~

Used for:
"""""""""

- Creating IDL interfaces from VSS signal definitions.
- Optionally generating :term:`Vehicle Device` and :term:`Basic Service` components.

Why is `your_csv_file.csv` needed?
""""""""""""""""""""""""""""""""""

This CSV file is the **core input** for `sdv_vss_util`. It defines the structure and behavior of signals in the system, including:

- Which components are generated (`VD` or `BS`)
- What signals they handle
- How those signals are mapped to VSS paths and CAN messages

Each row in the CSV represents a signal and its metadata. The tool uses this to generate:

- `.idl` files for interface definitions
- `.cpp/.h` files for VD and BS components
- `SignalIdentifier.h` and `Summary.txt` for reference

**Required columns in the CSV:**

+----------------------+-------------------------------------------------------------+
| Column Name          | Description                                                 |
+======================+=============================================================+
| `Device Type`        | Specifies whether the row defines a VD or BS component      |
+----------------------+-------------------------------------------------------------+
| `Class name`         | The name of the generated class (e.g., `FrontWiper`)        |
+----------------------+-------------------------------------------------------------+
| `Function name`      | Logical function name (e.g., `IsActive`, `Mode`)            |
+----------------------+-------------------------------------------------------------+
| `Signal name`        | Internal signal identifier (e.g., `frontWiperActive`)       |
+----------------------+-------------------------------------------------------------+
| `vss`                | Full VSS path (e.g., `Vehicle.Body.Windshield.Wiper.Front`) |
+----------------------+-------------------------------------------------------------+
| `Signal direction`   | `TX` for transmit, `RX` for receive                         |
+----------------------+-------------------------------------------------------------+
| `type`               | Data type of the signal (`boolean`, `string`, etc.)         |
+----------------------+-------------------------------------------------------------+
| `DBC CAN name`       | CAN mapping (e.g., `CAN_Output.FrontWiperActive`)           |
+----------------------+-------------------------------------------------------------+

Example row:
''''''''''''

.. code-block:: console

	VD;FrontWiper;IsActive;frontWiperActive;Vehicle.Body.Windshield.Wiper.Front;TX;boolean;CAN_Output.FrontWiperActive

This row will generate:

- A `VD_FrontWiper` class with a signal `m_frontWiperActive`
- Methods like `WriteFrontWiperActive(bool)` to publish the signal
- An interface `IVSS_WriteFrontWiperActive` in the corresponding `.idl` file

.. tip::

	- Ensure consistent naming and no spaces in CSV cells.
	- Use `VD` for low-level signal handling and `BS` for high-level service logic.

Example usage:
''''''''''''''

.. code-block:: console

   sdv_vss_util.exe your_csv_file.csv -Ogenerated/ --prefix your_prefix --version 1.0.0.1 --enable_components

Output:
'''''''

- `generated/vss_files/BS_ClassName/...`
- `generated/vss_files/VD_ClassName/...`
- `generated/SignalIdentifier.h`
- `generated/Summary.txt`
- `generated/VSS_*.idl`


**VD_ Files -** `Vehicle Device`
''''''''''''''''''''''''''''''''

These files define **device-level components** that interact directly with VSS signals.
They are responsible for **publishing or subscribing to raw signal data**, typically mapped to CAN messages.

- Example: ``VD_FrontWiper.cpp/.h``
- Contains:
	- A class like ``CVehicleDeviceFrontWiper``
	- Signal objects (e.g. ``m_wiperSpeed``)
	- Methods like ``WriteWiperSpeed(int)`` to publish values
	- Initialization and lifecycle management (Initialize, Shutdown, etc.)
- Inherits from interfaces like ``IVSS_WriteWiperSpeed``


**BS_ Files -** `Basic Service`
'''''''''''''''''''''''''''''''

These files define **service-level components** that expose **application-level functionality** to other modules or external systems.

- Example: ``BS_FrontWiper.cpp/.h``
- Contains:
	- A class like ``CBasicServiceFrontWiper``
	- Methods like ``SetWiperSpeed(int)`` that call into the corresponding ``VD_`` device
	- Interface exposure for service APIs (e.g. ``IVSS_SetWiperSpeed``)
- Acts as a wrapper or bridge to the underlying ``VD_`` logic

**Key Differences**

- Purpose:
	- ``VD_ Files``: Low-level signal handling
	- ``BS_ Files``: High-level signal handling

- Signal Access:
	- ``VD_ Files``: Direct (via ``CSignal``)
	- ``BS_ Files``: Indirect (via device interface)

- Role in System:
	- ``VD_ Files``: Data source/sink
	- ``BS_ Files``: Functional API for control modules

.. _sdv_idl_compiler:

sdv_idl_compiler
~~~~~~~~~~~~~~~~

**Used for:**

- Generating communication interfaces for Complex Services and Applications.
- Enables isolated components to interact across process boundaries.
- **Required step** after running `sdv_vss_util`: all IDL files generated by `sdv_vss_util` must be compiled using `sdv_idl_compiler`.
- The compilation process produces `.h` header files for each `.idl` file, which are essential for building proxy/stub communication layers.

**Example usage:**

.. code-block:: console

	sdv_idl_compiler.exe generated/vss_files/VSS_VehicleBodyWeatherRain_bs_rx.idl -Ogenerated/vss_files/ -ID:\Repo_VAPI\vapi-cpp-vehicle-api-platform\export -Igenerated/vss_files/ --no_ps

**What a Generated `.h` File Contains**

Each `.h` file generated by `sdv_idl_compiler` from an `.idl` file contains:

- **Interface definitions** for service and event communication.
- **Unique interface IDs** used for runtime identification and binding.
- **Pure virtual methods** that define the contract for signal access and event handling.
- **Callback registration methods** for subscribing to signal changes.

.. tip::
	- Always compile all `.idl` files generated by `sdv_vss_util` before building the application.
	- These headers are required for both VD and BS components to link against the correct interfaces.

.. _sdv_dbc_util:

sdv_dbc_util
~~~~~~~~~~~~

**Used for:**

- Generating `can_dl` (CAN datalink) code.
- Creating components to read/write CAN signals.
- (Optional) Creating FMU-compatible modules for simulation .

.. note:: FMU generation is **optional** and only required if the system is intended to be used in a **simulation environment** (e.g., OpenXil). If simulation is not needed, you can skip the `--module` option in `sdv_dbc_util`, and the `fmu_/` folder will not be generated.

.. raw:: html

    <code>
    sdv_dbc_util.exe 
    <span style="color: blue; font-weight: bold;">your_dbc_file.dbc</span> 
    -O<span style="color: blue; font-weight: bold;">generated\</span> 
    --nodes<span style="color: blue; font-weight: bold;">your_nodes_name</span> 
    --version1.0.0.1 
    --module<span style="color: blue; font-weight: bold;">your_FMU_name</span> 
    --dl_lib_name<span style="color: blue; font-weight: bold;">your_can_dl_lib_name</span>
    </code>

.. note:: Blue text must be your input.

**Output:**

- `generated/can_dl/`
- `generated/fmu_<your_FMU_name>/`

**can_dl -**  ``datalink.cpp`` & ``datalink.h``  
These files define and implement the ``CDataLink`` class, which serves as the interface between the CAN communication layer and the V-API application.  
Includes logic for initializing CAN interfaces, registering message receivers, handling incoming CAN messages, and managing signal dispatching.  
The header file declares the structure and interfaces, while the source file provides the operational logic for initialization, shutdown, and message handling.

**fmu_**  
    *to-do*


.. _input-files:

Input Files
-----------

To initiate auto code generation, the following input files must be created:

**your_csv_file.csv**

Describes signals and services for Vehicle Devices (VD) and Basic Services (BS). Must include columns such as:

- Device Type (``VD`` or ``BS``)
- Class name
- Function name
- Signal name
- VSS path
- Direction (``RX`` or ``TX``)
- Signal value type
- CAN name or Interface


Formatting rules:

- No spaces in cells
- Consistent naming conventions

**your_dbc_file.dbc**

Defines the CAN bus layout and message structure. Must include:

- All signals available on the CAN bus and FMU
- Consistent naming, units, and scaling

Generated Components
--------------------

**VD_ (Vehicle Device) Files**

- Represent low-level components that interact directly with VSS signals.
- Handle publishing or subscribing to raw signal data.
- Example: `VD_FrontWiper.cpp/.h`
- Inherit interfaces like `IVSS_WriteWiperSpeed`
- Contain signal objects and methods like `WriteWiperSpeed(int)` to publish values.

**BS_ (Basic Service) Files**

- Represent high-level service components that expose application-level functionality.
- Act as wrappers around VD components.
- Example: `BS_FrontWiper.cpp/.h`
- Inherit interfaces like `IVSS_SetWiperSpeed`
- Contain methods like `SetWiperSpeed(int)` that delegate to the corresponding VD device.

Tool Options
------------

**sdv_vss_util** options:

.. code-block:: console

    --prefix<string>           Adds a prefix to signal identifiers.
    --enable_components        Generates component code in addition to IDL.
    --version<string>          Optional version tag.
    -O<path>                   Required output directory.

**sdv_dbc_util** options:

.. code-block:: console

    --dl_lib_name<string>      Name of the generated datalink library.
    --nodes<string>[,<string>] Specifies which nodes to implement.
    --module<string>           FMU module identifier.
    -O<path>                   Output directory.

**sdv_idl_compiler** options:

.. code-block:: console

    -I<path>                   Include directories.
    -O<path>                   Output directory.
    --no_ps                    Skip proxy/stub generation.
    --ps_lib_name<string>      Name of proxy/stub library.
    --strict                   Enforce OMG-IDL conformance.

Tips
--------------------------------------------------------------------------------

- Run tools manually first before automating in CMake.
- Avoid spaces in signal names and file paths.
- Use consistent naming conventions for signals and classes.
