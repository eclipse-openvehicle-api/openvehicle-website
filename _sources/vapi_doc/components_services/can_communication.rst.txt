.. _vapi-can-implementation:

CAN Implementations
===================

       | The framework contains already 3 different CAN components:
       | can_com_sim.sdv    -  CAN implementation based on asc text file
       | can_com_sockets    -  CAN implementation based on sockets 
       | can_com_silkit.sdv -  CAN implementation based on Vector SIL-Kit

CAN implementation based on asc text file
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

       | The can messages are communicated by reading and writing the messages which are in ASC file format. 

**ASC file in CAN simulation:**

- It is a plain text file format used to store data in the American Standard Code for Information Interchange (ASCII) standard. 
- IT is important for logging and analyzing CAN bus traffic. They are human-readable text files that log each CAN frame with a timestamp and message details.
- These ASC files support basic characters like letters, numbers and punctuation. 
- Each character matches with the character in the ASCII code. 
- The CAN messages which are encoded in ASCII format are read and written via the given .asc file.

**Structure of a CAN .asc File:**

A typical .asc file from a CAN logger (like Vector CANalyzer or CANoe) might look like:

       | <timestamp> <channel> <message type> <ID> <DLC> <data bytes> [flags]

Example .asc file:

.. figure:: ../../vapi_media/can_communication/ex_asc_file.png

Each line includes:

.. list-table::
   :header-rows: 1

   * - Elements
     - Definition
   * - 0.007096
     - Timestamp in seconds, When the message was received
   * - 1
     - CAN channel number 
   * - B6 
     - Message ID(in decimal or hexadecimal)  
   * - Rx 
     - Message direction (Rx = received, Tx = transmitted) 
   * - d 
     - Frame type (d = data frame, r = remote frame)  
   * - 5
     - DLC (Data Length Code), Number of data bytes   
   * - 06 06 80 00 C8
     - Actual payload of the CAN message  
   
**Usage in CAN Communication:**

- Logging: Capturing CAN traffic during testing or operation.
- Debugging: Analyzing communication issues between ECUs (Electronic Control Units).
- Simulation: Replaying CAN traffic to simulate real-world scenarios.
- Data Analysis: Feeding into tools/scripts for performance or fault analysis.
- Interoperability: Sharing logs between different tools and teams.

.. figure:: ../../vapi_media/can_communication/can_simulation.png

- The diagram shows that the vapi can simulation component reads the can messages from .asc file, send messages to application via data link and vapi services.
- In order to write messages in to .asc file, the can messages are send via vapi can simulation component from data link to writer .asc file.

**Working with CAN hardware:**

To work with actual Controller Area Network (CAN) hardware, we need:

- A CAN interface device (e.g., USB-to-CAN adapters like Peak, Kvaser, or SocketCAN-compatible devices).
- A physical CAN bus setup (e.g., ECUs, sensors, or other CAN nodes).
- Proper termination (120-ohm resistors at both ends of the bus).

when we need to do the software setup, follow below steps for linux:

.. code-block:: text

       sudo modprobe can
       sudo modprobe can_raw
       sudo modprobe mttcan  # or your specific driver
       sudo ip link set can0 up type can bitrate 50000

we can use SocketCAN when we don't have the actual CAN hardware.

CAN implementation based on socket can
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

- It is a software based CAN bus, through which developers can develop and test the CAN nodes without the actual CAN hardware.
- It is a set of open-source CAN drivers and a networking stack that is part of the Linux kernel.
- It allows CAN devices to be treated like network interfaces, making it easier to develop and debug CAN-based applications.
- Allow developers to use familiar socket programming techniques for CAN communication.
- Support both Classical CAN and CAN FD (Flexible Data-rate).

**Components of SocketCAN:**

- CAN Drivers: Kernel modules for CAN hardware (e.g., can, can_raw, can_dev).
- CAN Utilities: Tools like candump, cansend, part of the can-utils package.
- CAN Interfaces: Devices like can0, can1 appear as network interfaces.

**Tools for SocketCAN:**

The can-utils package provides user-space tools for working with SocketCAN. Some commonly used tools include:

- candump: Displays and logs CAN traffic.
- cansend: Sends a single CAN frame.
- cangen: Generates random CAN traffic.
- cansniffer: Monitors and highlights changes in CAN data.

**Installation of SocketCAN on linux system:**

Step 1: Install CAN Utilities:

.. code-block:: text 

       sudo apt update
       sudo apt install can-utils

It install the can-utils package, which provides tools like candump, cansend, etc.

Step 2: Load the vcan Kernel Module:

.. code-block:: text 
       
       sudo modprobe vcan

Step 3: Create a Virtual CAN Interface:

.. code-block:: text 

       sudo ip link add dev vcan0 type vcan

Step 4: Bring the Interface Up:

.. code-block:: text 

       sudo ip link set up vcan0

Step 5: verify the interface:

.. code-block:: text 

       ip link show vcan0

Use above mentioned commands when we use a virtual CAN interface for testing

**Communication Test:**

- After successful installation of can-utils and brought up the can interface, we can test how the vcan works by opening two different terminals.
- Give the below mentioned commands to send and receive a can message. 

Send a CAN Frame:

.. code-block:: text

       cansend vcan0 123#DEADBEEF

Receive CAN Frames:

.. code-block:: text

       candump vcan0

.. figure:: ../../vapi_media/can_communication/vcan_send_rec.png 

**CAN data communication via socket can:**

.. figure:: ../../vapi_media/can_communication/socket_can_comm.png

- The above image shows that the socket can reads the can messages from can bus, send messages to application via data link and vapi services.
- In order to write messages in to can bus, the can messages are send via socket can from data link to can bus.


**Explanation of test code using socket can:**

.. figure:: ../../vapi_media/can_communication/socket_can_test_code.png 

- The above image shows that the application which has to send or receive can data will be started by loading vapi core services.
- The vcan interfaces through which we are going to send and receive can messages should be initialized.
- After setting it to configuration mode, the receivers who are going to receive messages should be registered.
- The data will be send via the configured vcan interface in the running mode.
- Once the data was send, the registered receiver receives data immediately.
- After sending and receiving all data, the receiver should be unregistered and socket can will be closed, through which we cannot start the communication.

CAN implementation based on Vector SIL-Kit
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

**Vector SilKit**

- Vector SIL Kit, is an open-source software library developed by Vector Informatik for connecting Software-in-the-Loop environments.
- It's designed to facilitate communication between various simulation tools, virtual ECUs, emulators, and test systemsâ€”especially useful in automotive and embedded systems development.
- It supports various vehicle network controllers like CAN, Ethernet, FlexRay and LIN.
- provides publish/subscribe mechanism for data communication.


**Start with Vector SilKit**

1. How to install:

.. code:: text

       clone the <https://github.com/vectorgrp/sil-kit>_

2. Initialize submodules:

.. code:: text

       git submodule update --init --recursive

3. Build using CMake:

.. code:: text

       mkdir build
       cd build
       cmake ..
       make

**Vector SilKit Utilities**

1. sil-kit-registry:

- It is the mandatory part of the vector silkit which provides connection between simulation participants. 
- provides SIL Kit participants with information of available participants and how to connect to them
- The SIL Kit Registry must be started before other SIL Kit participants.
- Usage: Open a separate terminal 

.. code:: text

       ./sil-kit-registry

2. sil-kit-system-controller:

- It defines the required participants for the simulation.
- Usage: Open a separate terminal 

.. code:: text

       ./sil-kit-system-controller ./Participant1 ./Participant2

3. sil-kit-monitor:

- It visualizes the states of the participants
- Usage: Open a separate terminal 

.. code:: text

       ./sil-kit-monitor

Participants can be configured to coordinate their simulation start and stop behavior with other participants through use of the **Lifecycle Service**. 
To synchronize their virtual time with others, a participant can use the **Time Synchronization Service**.
