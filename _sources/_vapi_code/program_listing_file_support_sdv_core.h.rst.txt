
.. _program_listing_file_support_sdv_core.h:

Program Listing for File sdv_core.h
===================================

|exhale_lsh| :ref:`Return to documentation for file <file_support_sdv_core.h>` (``support\sdv_core.h``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   #ifndef SDV_CORE_H
   #define SDV_CORE_H
   
   #ifndef DONT_LOAD_CORE_TYPES
   #include "../interfaces/core.h"
   #include "../interfaces/module.h"
   #endif
   #include "interface_ptr.h"
   #include <fstream>
   #include <filesystem>
   #include <string>
   #include <cctype>
   #include <stdlib.h>
   #include <functional>
   
   #ifdef _WIN32
   // Resolve conflict
   #pragma push_macro("interface")
   #pragma push_macro("GetObject")
   #undef interface
   
   #ifndef NOMINMAX
   #define NOMINMAX
   #endif
   
   #include <WinSock2.h>
   #include <Windows.h>
   #include <objbase.h>
   
   // Resolve conflict
   #pragma pop_macro("interface")
   #pragma pop_macro("GetObject")
   #ifdef GetClassInfo
   #undef GetClassInfo
   #endif
   
   #ifdef __GNUC__
   #pragma GCC diagnostic push
   #pragma GCC diagnostic ignored "-Wcast-function-type"
   #endif
   #elif defined __unix__
   #include <dlfcn.h>
   #include <unistd.h>
   #include <limits.h>
   #else
   #error OS is not supported!
   #endif
   
   namespace sdv
   {
       namespace core
       {
           namespace internal
           {
               class CSDVCoreLoader
               {
               public:
                   CSDVCoreLoader() = default;
   
                   ~CSDVCoreLoader()
                   {
                       // Free the library
                       if (m_tModule)
   #ifdef _WIN32
                           FreeLibrary(reinterpret_cast<HMODULE>(m_tModule));
   #elif defined __unix__
                           dlclose(reinterpret_cast<void*>(m_tModule));
   #else
   #error OS not supported!
   #endif
                   }
   
                   void Load()
                   {
                       if (m_bInit) return;    // Prevent trying to load again.
                       m_bInit = true;
   
                       // Check for the executable directory
                       std::filesystem::path pathCoreLib;
                       if (std::filesystem::exists(GetExecDirectory() / "core_services.sdv"))
                           pathCoreLib = GetExecDirectory() / "core_services.sdv";
                       // Check for the local config file
                       if (pathCoreLib.empty() && std::filesystem::exists(GetExecDirectory() / "sdv_core_reloc.toml"))
                       {
                           std::ifstream fstream(GetExecDirectory() / "sdv_core_reloc.toml");
                           std::string ssLine;
                           while (std::getline(fstream, ssLine))
                           {
                               size_t nPos = 0;
                               auto fnSkipWhitespace = [&]() { while (std::isspace(ssLine[nPos])) nPos++; };
                               fnSkipWhitespace();
                               if (ssLine[nPos] == '#') continue;  // Rest of the line is comments
                               if (ssLine.substr(nPos, 9) != "directory") continue;    // not the keq of interest: skip line
                               nPos += 9;
                               fnSkipWhitespace();
                               if (ssLine[nPos] != '=')
                               {
                                   std::cout << "Error in \"sdv_core_reloc.toml\": expecting assignment character '=' following"
                                       " keyword 'directory'." << std::endl;
                                   break;
                               }
                               nPos++;
                               fnSkipWhitespace();
                               if (ssLine[nPos] != '\"')
                               {
                                   std::cout << "Error in \"sdv_core_reloc.toml\": expecting double quote character '\"' indicating"
                                       " a string begin'." << std::endl;
                                   break;
                               }
                               nPos++;
                               size_t nStart = nPos;
                               while (nPos < ssLine.length() && ssLine[nPos] != '\"')
                               {
                                   // Check for escape character
                                   if (ssLine[nPos] == '\\') nPos++;
   
                                   // Skip character
                                   nPos++;
                               }
                               if (nPos >= ssLine.length() || ssLine[nPos] != '\"')
                               {
                                   std::cout << "Error in \"sdv_core_reloc.toml\": expecting double quote character '\"' indicating"
                                       " a string end'." << std::endl;
                                   break;
                               }
                               std::string ssDirectory = ssLine.substr(nStart, nPos - nStart);
                               while (ssDirectory.empty())
                               {
                                   std::cout << "Error in \"sdv_core_reloc.toml\": expecting a valid value following the assignment"
                                       " of the 'directory' key." << std::endl;
                                   break;
                               }
                               pathCoreLib = std::filesystem::path(ssDirectory) / "core_services.sdv";
                               if (pathCoreLib.is_relative())
                                   pathCoreLib = (GetExecDirectory() / pathCoreLib).lexically_normal();
                               break;
                           }
                       }
                       // Check for the environment variable
   #ifdef _WIN32
                       std::wstring ssPathCoreTemp(32768, '\0');
                       GetEnvironmentVariable(L"SDV_FRAMEWORK_RUNTIME", ssPathCoreTemp.data(), static_cast<DWORD>(ssPathCoreTemp.size()));
                       ssPathCoreTemp.resize(wcsnlen(ssPathCoreTemp.c_str(), ssPathCoreTemp.size()));
                       if (pathCoreLib.empty() && !ssPathCoreTemp.empty())
                       {
                           pathCoreLib = std::filesystem::path(ssPathCoreTemp) / "core_services.sdv";
   #else
                       if (pathCoreLib.empty() && getenv("SDV_FRAMEWORK_RUNTIME"))
                       {
                           pathCoreLib = std::filesystem::path(getenv("SDV_FRAMEWORK_RUNTIME")) / "core_services.sdv";
   #endif
                           if (pathCoreLib.is_relative())
                               pathCoreLib = (GetExecDirectory() / pathCoreLib).lexically_normal();
                       }
   
                       // Depend on system path to find the library
                       if (pathCoreLib.empty())
                           pathCoreLib = "core_services.sdv";
   
                       // Open the library
   #ifdef _WIN32
                       SetErrorMode(SEM_FAILCRITICALERRORS);
                       m_tModule = reinterpret_cast<core::TModuleID>(LoadLibraryW(pathCoreLib.native().c_str()));
   #elif defined __unix__
                       m_tModule = reinterpret_cast<core::TModuleID>(dlopen(pathCoreLib.native().c_str(), RTLD_LAZY));
   #else
   #error OS is not supported!
   #endif
                       if (!m_tModule)
                       {
                           std::string ssError;
   #ifdef _WIN32
                           ssError.resize(1024);
                           ssError.resize(FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS, NULL, GetLastError(),
                               MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), &ssError.front(), 1024, NULL));
                           while (!ssError.empty() && std::isspace(ssError.back())) ssError.pop_back();
   #elif defined __unix__
                           const char* szError = dlerror();
                           if (szError) ssError = szError;
   #else
   #error OS is not supported!
   #endif
                           std::cerr << "Could not load \"core_services.sdv\" library";
                           if (!ssError.empty()) std::cerr << ": " << ssError;
                           std::cerr << std::endl;
                           return;
                       }
   
                       // Get the SDVCore function pointer
                       using TFNSDVCore = IInterfaceAccess*();
   #ifdef _WIN32
                       std::function<TFNSDVCore> fnSDVCore =
                           reinterpret_cast<TFNSDVCore*>(GetProcAddress(reinterpret_cast<HMODULE>(m_tModule), "SDVCore"));
   #elif defined __unix__
                       std::function<TFNSDVCore> fnSDVCore =
                           reinterpret_cast<TFNSDVCore*>(dlsym(reinterpret_cast<void*>(m_tModule), "SDVCore"));
   #else
   #error OS is not supported!
   #endif
                       if (!fnSDVCore)
                       {
                           std::cerr << "The library \"core_services.sdv\" doesn't expose the SDVCore function." << std::endl;
                           return;
                       }
   
                       // TODO: Add version check!
   
                       // Get the core interface
                       m_pCore = fnSDVCore();
                       if (!m_pCore)
                       {
                           std::cerr << "The library \"core_services.sdv\" doesn't provide a valid interface." << std::endl;
                           return;
                       }
                   }
   
                   operator TInterfaceAccessPtr() const { return m_pCore; }
   
               private:
                   static std::filesystem::path GetExecDirectory()
                   {
   #ifdef _WIN32
                       // Windows specific
                       std::wstring ssPath(32768, '\0');
                       GetModuleFileNameW(NULL, ssPath.data(), static_cast<DWORD>(ssPath.size() - 1));
   #elif defined __linux__
                       // Linux specific
                       std::string ssPath(PATH_MAX + 1, '\0');
                       const ssize_t nCount = readlink("/proc/self/exe", ssPath.data(), PATH_MAX);
                       if (nCount < 0 || nCount >= PATH_MAX)
                           return {}; // some error
                       ssPath.at(nCount) = '\0';
   #else
   #error OS is not supported!
   #endif
                       return std::filesystem::path{ssPath.c_str()}.parent_path() / ""; // To finish the folder path with (back)slash
                   }
   
                   bool                m_bInit = false;        
                   core::TModuleID     m_tModule = 0;          
                   IInterfaceAccess*   m_pCore = nullptr;      
               };
           } // namespace internal
   
   #ifndef NO_SDV_CORE_FUNC
           inline TInterfaceAccessPtr GetCore()
           {
               static internal::CSDVCoreLoader core;
               core.Load();
               return core;
           }
   
           template <typename TInterface>
           inline TInterface* GetCore()
           {
               return GetCore().GetInterface<TInterface>();
           }
   #endif
       }
   }
   
   
   #endif // !define SDV_CORE_H
