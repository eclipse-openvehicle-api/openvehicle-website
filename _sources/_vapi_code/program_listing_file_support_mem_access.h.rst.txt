
.. _program_listing_file_support_mem_access.h:

Program Listing for File mem_access.h
=====================================

|exhale_lsh| :ref:`Return to documentation for file <file_support_mem_access.h>` (``support\mem_access.h``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   #ifndef MEM_SUPPORT_H
   #define MEM_SUPPORT_H
   
   #include "../interfaces/mem.h"
   #include <map>
   #include <thread>
   #include <iostream>
   #include "interface_ptr.h"
   #include "sdv_core.h"
   
   namespace sdv
   {
       namespace core
       {
           // Forward declarations
           TInterfaceAccessPtr GetCore();
           template <typename TInterface>
           TInterface* GetCore();
   
           inline sdv::core::IMemoryAlloc* GetMemMgr()
           {
               static sdv::core::IMemoryAlloc* pAlloc = nullptr;
               static const sdv::IInterfaceAccess* pLocalServices = nullptr;
   
               // cppcheck warns that GetCore is always returning a pointer. This mechanism is preparing for the situation where the
               // core might be shut down and therefore there is no memory management any more. Suppress the warning.
               // cppcheck-suppress knownConditionTrueFalse
               if (GetCore())
               {
                   if (GetCore() != pLocalServices || !pAlloc)
                       pAlloc = GetCore<IMemoryAlloc>();
               }
               else
                   pAlloc = nullptr;
               pLocalServices = GetCore();
               return pAlloc;
           }
   
           inline pointer<uint8_t> AllocMemBytes(size_t nAmount)
           {
               sdv::core::IMemoryAlloc* pMemMgr = GetMemMgr();
               if (!pMemMgr)
                   throw sdv::core::XNoMemMgr{};
               pointer<uint8_t> ptrBuffer = pMemMgr->Allocate(static_cast<uint32_t>(nAmount));
               if (!ptrBuffer)
               {
                   sdv::core::XAllocFailed exception;
                   exception.uiSize = static_cast<uint32_t>(nAmount);
                   throw exception;
               }
               return ptrBuffer;
           }
   
           template <typename T /*= uint8_t*/>
           inline pointer<T> AllocMem(size_t nAmount)
           {
               return make_ptr<T>(nAmount);
               //pointer<uint8_t> ptrBuffer = AllocMemBytes(nAmount * sizeof(T));
               //T* pT = reinterpret_cast<T*>(ptrBuffer.get());
               //for (size_t nIndex = 0; nIndex < nAmount; nIndex++)
               //    new (pT + nIndex) T();
               //pointer<T> ptr;
               //ptr.attach(std::move(ptrBuffer));
               //return ptr;
           }
       } // namespace core
   } // namespace sdv
   
   
   #endif // !defined(MEM_SUPPORT_H)
